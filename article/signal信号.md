# 信号

## 代码样例

> [代码样例]()

## 什么是信号

信号是UNIX和Linux系统响应某些条件而产生的一个事件，接收到该信号的进程会相应地采取一些行动。通常信号是由一个错误产生地。但它们还可以作为进程间通信或修改行为的一种方式。一个信号的产生叫生成，接收到一个信号叫捕获。

> 信号是软件中断。信号提供了一种处理异步事件的方法：终端用户键入中断键，则会通过信号机构停止一个程序。

## 信号来源

信号事件的发生有两个来源

- 软件来源（比如我们按下了键盘或者其他硬件故障）

- 软件来源，最常用发送信号的系统函数是**kill**，raise，alarm和settimer以及**sigqueue**，软件来源可能还包括一些非法运算等操作。

信号可以直接进行用户进程和内核进程之间的交互，内核进程可以利用它来通知用户空间进程发生了哪些系统事件。
如果该进程当前并未出予执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，知道该阻塞被取消时才传递给进程。

## 实时信号与非实时信号

早期Unix系统只定义了32种信号，Ret hat7.2支持64种信号，编号0-63(SIGRTMIN=31，SIGRTMAX=63)，将来可能进一步增加，这需要得到内核的支持。

前32种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的CTRL ^C时，会产生SIGINT信号，对该信号的默认反应就是进程终止。后32个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。实时信号是POSIX标准的一部分，可用于应用进程。

**非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。**

## 信号的发送

发送信号的主要函数有：kill()、raise()、sigqueue()、alarm()、setitimer()以及abort()。

### kill-传送信号给指定进程

```shell
man 2 kill # ubutun下查看kill的帮助信息
```

```shell
kill -l	# 打印所有信号及其编号
```

**函数原型**

```c++
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int signo);
```

**参数说明**

- 第一个参数pid：指定发送信号的接收线程
- 第二个参数signo：信号的signum

**参数pid**

| pid            | 信号的接收进程                          |
| -------------- | --------------------------------------- |
| pid>0          | 进程ID为pid的进程                       |
| pid=0          | 同一个进程组的进程                      |
| pid<0&&pid!=-1 | 进程组ID为 -pid的所有有进程             |
| pid=-1         | 除发送进程自身外，所有进程ID大于1的进程 |

pid参数支持向其他进程组全组发送信号。

**参数signo**

Signo是信号值，当为0时（即空信号），实际不发送任何信号，但照常进行错误检查，因此，可用于检查目标进程是否存在，以及当前进程是否具有向目标发送信号的权限（root权限的进程可以向任何进程发送信号，非root权限的进程只能向属于同一个session或者同一个用户的进程发送信号）。

Kill()最常用于pid>0时的信号发送，调用成功返回 0； 否则，返回 -1。



