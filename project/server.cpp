#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <iostream>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <map>
#include <pthread.h>

using namespace std;

typedef struct chat {
	int chat_type;		// 聊天类型 私聊|群聊
	int sender_id;		// [重要]发送方id	双方必须互相指定
	int receiver_id;	// [重要]接收方id	双方必须互相指定
	char message[100];	// 信息
}CHAT;

int socket_fd;
int accept_fd;
struct sockaddr_in s_addr;		// 网络套接字结构体
pthread_t transpond_pthread_id;	// 客户端上线时为其开启的转发线程ID
int len;
map<int, int> accept_fd_map;


/* 服务器转发函数
* @param：p 传入线程函数使用的参数
*/
void* server_transpond(void* p) {
	int fd = *(int*)p;
	// 自定义聊天消息结构体
	CHAT chat_buf;
	// 接收客户端开启时发来的自报信息结构体，这是每个客户端都会经历的过程
	read(fd, &chat_buf, sizeof(CHAT));
	// key = 发送方id
	// value = 服务器与发送发建立的连接文件描述符accept_fd
	accept_fd_map[chat_buf.sender_id] = fd;
	cout << "已经为客户端" << chat_buf.sender_id << "建立向" << chat_buf.receiver_id << "的转发服务" << endl;
	while (1) {
		read(fd, &chat_buf, sizeof(CHAT));
		cout << "接收到客户端" << chat_buf.sender_id << "发往客户端" << chat_buf.receiver_id << "的消息:"
			<< chat_buf.message << endl;
		// 在以上线客户端中寻找 receiver
		if (accept_fd_map.find(chat_buf.receiver_id) == accept_fd_map.end()) {
			cout << "客户端" << chat_buf.receiver_id << "不在线" << endl;
			continue;
		}
		write(accept_fd_map[chat_buf.receiver_id], &chat_buf, sizeof(chat_buf));
		bzero(chat_buf.message, sizeof(chat_buf.message));
	}
}

int client() {

	/*
	* 搭建网络通路
	* 参数1：协议族
	* 参数2：协议类型
	* 参数3：因为第二个参数已经确定了协议类型，默认0
	*/
	socket_fd = socket(AF_INET, SOCK_STREAM, 0);

	if (socket_fd < 0) {
		perror("socket error");
	}
	else {
		// 协议族，一般情况下 IPV4=AF_INET
		s_addr.sin_family = AF_INET;
		// 设置端口号 9000以上，除此之外还有大小端问题，可以通过htons转换函数解决
		s_addr.sin_port = htons(10086);
		// 设置IP有Linux操作系统默认提供
			// 回环地址 127.0.0.1
		s_addr.sin_addr.s_addr = INADDR_ANY;// 注意建议使用 s_addr.sin_addr.s_addr 有两层addr

		len = sizeof(s_addr);

		int val = 1;
		int ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, (const void*)&val, sizeof(int));
		if (ret == -1) {
			printf("setsockopt");
			exit(1);
		}
		if (bind(socket_fd, (struct sockaddr*)&s_addr, len) < 0) {
			perror("bind error");
		}
		// 设置监听网络是否可行 设置网路同一时间能够接收几个客户端
		//（但此参数不重要），后期可以通过别的手段扩大连接数
		if (listen(socket_fd, 10)) {
			perror("listen error");
		}

		int client_count = 0;	// 客户端在线数量
		// 需要服务器长时间等待客户端上线
		while (1) {
			// 之前经过bind函数绑定后，accept的后两个参数可以不需要(给NULL)，这是版本更新留下的接口
			// 阻塞式函数，一直等待客户端访问，客户端一但访问成即返回accept_fd
			// 后续我们想要写入数据需要通过这个accept_fd
			accept_fd = accept(socket_fd, NULL, NULL);
			cout << "有客户端上线" << endl;

			// 开启子线程执行两客户端之间的消息转发
			// [重要]我们需要给子线程传递发送发的accept_fd
			//		虽然我们以及执行了记录
			if (pthread_create(&transpond_pthread_id, NULL, server_transpond, &accept_fd)) {
				perror("socket error");
			}
		}
		close(socket_fd);
	}
	return 0;
}


/* 出现bind error:Address already in use */
// 原因：一般来说，一个端口释放后会等待两分钟之后才能再被使用，SO_REUSEADDR是让端口释放后立即就可以被再次使用。
/* Ⅰ、首先在命令行使用 $ netstat -an|grep 端口号 查看对应端口号的状态
*  发现它可能处于TIME_WAIT 或者 ESTABLISHED 状态
*  使用 $ fuser -k 端口号/tcp 杀掉进程端口
*  Ⅱ、在bind之前使用这段代码，
*	int val = 1;
*	int ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, (void*)&val, sizeof(int));
*	if (ret == -1){
*		printf("setsockopt");
*		exit(1);
*	}
*	Q:编写 TCP/SOCK_STREAM 服务程序时，SO_REUSEADDR到底什么意思？
*
*   A:这个套接字选项通知内核，如果端口忙，但TCP状态位于 TIME_WAIT ，可以重用端口。如果端口忙，而TCP状态位于其他状态，重用端口时依旧得到一个错误信息，指明"地址已经使用中"。如果你的服务程序停止后想立即重启，而新套接字依旧使用同一端口，此时SO_REUSEADDR 选项非常有用。必须意识到，此时任何非期望数据到达，都可能导致服务程序反应混乱，不过这只是一种可能，事实上很不可能。
*
*   一个套接字由相关五元组构成，协议、本地地址、本地端口、远程地址、远程端口。SO_REUSEADDR 仅仅表示可以重用本地本地地址、本地端口，整个相关五元组还是唯一确定的。所以，重启后的服务程序有可能收到非期望数据。必须慎重使用SO_REUSEADDR 选项。【2】
*/